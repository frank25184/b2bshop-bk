"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PraisonAIAgents = exports.Agent = exports.Task = void 0;
const openai_1 = require("../llm/openai");
const logger_1 = require("../utils/logger");
class Task {
    constructor(config) {
        this.name = config.name;
        this.description = config.description;
        this.expected_output = config.expected_output;
        this.agent = config.agent || null;
        this.dependencies = config.dependencies || [];
        this.result = null;
        logger_1.Logger.debug(`Task created: ${this.name}`, { config });
    }
}
exports.Task = Task;
class Agent {
    constructor(config) {
        this.name = config.name;
        this.role = config.role;
        this.goal = config.goal;
        this.backstory = config.backstory;
        this.verbose = config.verbose || false;
        this.llm = new openai_1.OpenAIService(config.llm || 'gpt-4o-mini');
        this.markdown = config.markdown || true;
        this.result = '';
        logger_1.Logger.debug(`Agent created: ${this.name}`, { config });
    }
    async execute(task, dependencyResults) {
        logger_1.Logger.debug(`Agent ${this.name} executing task: ${task.name}`, {
            task,
            dependencyResults
        });
        const systemPrompt = `You are ${this.name}, a ${this.role}.
Your goal is to ${this.goal}.
Background: ${this.backstory}

You must complete the following task:
Name: ${task.name}
Description: ${task.description}
Expected Output: ${task.expected_output}

Respond ONLY with the expected output. Do not include any additional text, explanations, or pleasantries.`;
        let prompt = '';
        if (dependencyResults && dependencyResults.length > 0) {
            prompt = `Here are the results from previous tasks that you should use as input:
${dependencyResults.map((result, index) => `Task ${index + 1} Result:\n${result}`).join('\n\n')}

Based on these results, please complete your task.`;
            logger_1.Logger.debug('Using dependency results for prompt', { dependencyResults });
        }
        else {
            prompt = 'Please complete your task.';
        }
        logger_1.Logger.debug('Preparing LLM request', {
            systemPrompt,
            prompt
        });
        if (this.verbose) {
            logger_1.Logger.info(`\nExecuting task for ${this.name}...`);
            logger_1.Logger.info(`Task: ${task.name}`);
            logger_1.Logger.info('Generating response (streaming)...\n');
        }
        // Reset result
        this.result = '';
        // Stream the response and collect it
        await this.llm.streamText(prompt, systemPrompt, 0.7, (token) => {
            if (this.verbose) {
                process.stdout.write(token);
            }
            this.result += token;
        });
        if (this.verbose) {
            console.log('\n'); // Add newline after streaming
        }
        logger_1.Logger.debug(`Agent ${this.name} completed task: ${task.name}`, {
            result: this.result
        });
        return this.result;
    }
}
exports.Agent = Agent;
class PraisonAIAgents {
    constructor(config) {
        this.agents = config.agents;
        this.tasks = config.tasks;
        this.verbose = config.verbose || false;
        this.process = config.process || 'sequential';
        this.manager_llm = config.manager_llm || 'gpt-4o-mini';
        logger_1.Logger.debug('PraisonAIAgents initialized', { config });
    }
    async start() {
        logger_1.Logger.debug('Starting PraisonAI Agents execution...');
        logger_1.Logger.debug('Starting with process mode:', this.process);
        let results;
        switch (this.process) {
            case 'parallel':
                logger_1.Logger.debug('Executing tasks in parallel');
                results = await Promise.all(this.tasks.map(task => {
                    if (!task.agent)
                        throw new Error(`No agent assigned to task: ${task.name}`);
                    return task.agent.execute(task);
                }));
                break;
            case 'hierarchical':
                logger_1.Logger.debug('Executing tasks hierarchically');
                results = await this.executeHierarchical();
                break;
            default:
                logger_1.Logger.debug('Executing tasks sequentially');
                results = await this.executeSequential();
        }
        if (this.verbose) {
            logger_1.Logger.info('\nPraisonAI Agents execution completed.');
            results.forEach((result, index) => {
                logger_1.Logger.info(`\nFinal Result from Task ${index + 1}:`);
                console.log(result);
            });
        }
        logger_1.Logger.debug('Execution completed', { results });
        return results;
    }
    async executeSequential() {
        logger_1.Logger.debug('Starting sequential execution');
        const results = [];
        for (const task of this.tasks) {
            if (!task.agent)
                throw new Error(`No agent assigned to task: ${task.name}`);
            logger_1.Logger.debug(`Executing task: ${task.name}`);
            const result = await task.agent.execute(task);
            results.push(result);
            task.result = result;
            logger_1.Logger.debug(`Completed task: ${task.name}`, { result });
        }
        return results;
    }
    async executeHierarchical() {
        const startTime = process.env.LOGLEVEL === 'debug' ? Date.now() : 0;
        logger_1.Logger.debug('Starting hierarchical execution');
        const results = [];
        for (const task of this.tasks) {
            const taskStartTime = process.env.LOGLEVEL === 'debug' ? Date.now() : 0;
            if (!task.agent)
                throw new Error(`No agent assigned to task: ${task.name}`);
            logger_1.Logger.debug(`Executing task: ${task.name}`, {
                dependencies: task.dependencies.map(d => d.name)
            });
            const depResults = task.dependencies.map(dep => dep.result);
            logger_1.Logger.debug(`Dependency results for task ${task.name}`, { depResults });
            const result = await task.agent.execute(task, depResults);
            results.push(result);
            task.result = result;
            if (process.env.LOGLEVEL === 'debug') {
                logger_1.Logger.debug(`Task execution time for ${task.name}: ${Date.now() - taskStartTime}ms`);
            }
            logger_1.Logger.debug(`Completed task: ${task.name}`, { result });
        }
        if (process.env.LOGLEVEL === 'debug') {
            logger_1.Logger.debug(`Total hierarchical execution time: ${Date.now() - startTime}ms`);
        }
        return results;
    }
}
exports.PraisonAIAgents = PraisonAIAgents;
